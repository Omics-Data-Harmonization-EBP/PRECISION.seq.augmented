library(sva)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("sva")
library(sva)
ComBat_seq()
?ComBat_seq()
load("C:/Users/jianz/OneDrive/Ongoing_Project/Methodology/202105_precision.seq.clustering/20230315_v3A/data/data_source/simulated_data.RData")
sessionInfo()
## from CRAN
CRAN.packages <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
}
CRAN.packages(c("PoissonSeq", "DescTools", "BiocManager", "readr", "magrittr", "ggplot2", "ggrepel", "ggdendro", "data.table", "tidyr", "dplyr", "ggplotify", "cluster"))
## from Bioconductor
Bioconductor.packages <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
BiocManager::install(new.pkg, dependencies = TRUE)
}
Bioconductor.packages(c("DESeq2", "edgeR", "affy", "sva", "RUVSeq", "EDASeq", "limma", "preprocessCore", "ffpe", "Biobase", "vsn"))
install.packages("BiocManager")
install.packages("BiocManager")
Bioconductor.packages <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
BiocManager::install(new.pkg, dependencies = TRUE)
}
Bioconductor.packages(c("DESeq2", "edgeR", "affy", "sva", "RUVSeq", "EDASeq", "limma", "preprocessCore", "ffpe", "Biobase", "vsn"))
BiocManager::install("DESeq2")
install.packages("BiocManager")
install.packages("BiocManager")
BiocManager::install("DESeq2")
BiocManager::install("DESeq2")
BiocManager::install("DESeq2")
Bioconductor.packages(c("DESeq2", "edgeR", "affy", "sva", "RUVSeq", "EDASeq", "limma", "preprocessCore", "ffpe", "Biobase", "vsn"))
BiocManager::install("sva")
BiocManager::install("sva")
BiocManager::install("sva")
BiocManager::install("sva")
BiocManager::install("sva")
library(sva)
BiocManager::install("sva")
library(sva)
BiocManager::install("sva")
BiocManager::install("sva")
install.packages("C:/Users/jianz/Downloads/sva_3.48.0.tar.gz")
library(sav)
library(sva)
BiocManager::install("EDASeq")
install.packages("C:/Users/jianz/Downloads/EDASeq_2.34.0.tar.gz")
BiocManager::install("ShortRead")
install.packages("C:/Users/jianz/Downloads/EDASeq_2.34.0.tar.gz")
BiocManager::install("ShortRead")
install.packages("C:/Users/jianz/Downloads/EDASeq_2.34.0.tar.gz")
library(ShortRead)
install.packages("C:/Users/jianz/Downloads/ShortRead_1.58.0.tar.gz")
install.packages("C:/Users/jianz/Downloads/aroma.light_3.30.0.tar.gz")
BiocManager::install("ShortRead")
BiocManager::install("ShortRead")
library(ShortRead)
BiocManager::install("Rhtslib")
install.packages("C:/Users/jianz/Downloads/Rhtslib_2.2.0.tar.gz")
install.packages("C:/Users/jianz/Downloads/EDASeq_2.34.0.tar.gz")
install.packages("C:/Users/jianz/Downloads/ShortRead_1.58.0.tar.gz")
install.packages("C:/Users/jianz/Downloads/EDASeq_2.34.0.tar.gz")
BiocManager::install("RUVSeq")
BiocManager::install("RUVSeq")
install.packages("C:/Users/jianz/Downloads/RUVSeq_1.34.0.tar.gz")
install.packages("aricode")
install.packages("RSKC")
install.packages("factoextra")
library(PRECISION.seq.augmented)
library(PoissonSeq)
library(PoissonSeq)
?PoissonSeq
library(PRECISION.seq.augmented)
precision <- methods::setClass(
"precision",
slots = c(
raw.train.data = "list",  ## for the clustering, we only consider the train data
raw.test.data = "list",
harmon.train.data = "list",
harmon.test.data = "list",
classification.result = "list",
cluster.result = "list"
)
)
create_precision.cluster <- function(data, label) {
object <- methods::new(Class = "precision",
raw.train.data = list(data = data, label = label),
raw.test.data = NULL)
return(object)
}
set.seed(123)  # Set a seed for reproducibility
total_judges <- 50
votes_per_judge <- 3
total_participants <- 20
simulations <- 10000  # Number of simulations to perform
# Function to simulate one round of voting
simulate_voting <- function(total_judges, votes_per_judge, total_participants) {
votes <- rep(0, total_participants)
for (j in 1:total_judges) {
# Each judge gives votes to 3 different participants
participants <- sample(total_participants, votes_per_judge, replace = FALSE)
for (p in participants) {
votes[p] <- votes[p] + 1
}
}
return(votes)
}
# Function to perform the simulation and calculate probabilities
calculate_probabilities <- function(total_judges, votes_per_judge, total_participants, simulations) {
selected_count <- rep(0, total_judges)
for (s in 1:simulations) {
votes <- simulate_voting(total_judges, votes_per_judge, total_participants)
top_four <- sort(votes, decreasing = TRUE)[1:4]
for (v in top_four) {
selected_count[v] <- selected_count[v] + 1
}
}
probabilities <- selected_count / simulations
names(probabilities) <- 1:total_judges
return(probabilities)
}
# Calculate the probabilities
probabilities <- calculate_probabilities(total_judges = 50, votes_per_judge = 3, total_participants = 20, simulations = 10000)
probabilities
sample(20, 3, replace = F)
simulate_voting(50, 3, 20)
probabilities
set.seed(123)  # Set a seed for reproducibility
total_judges <- 50
votes_per_judge <- 3
total_participants <- 20
simulations <- 10000  # Number of simulations to perform
# Function to simulate one round of voting
simulate_voting <- function(total_judges, votes_per_judge, total_participants) {
votes <- rep(0, total_participants)
for (j in 1:total_judges) {
# Each judge gives votes to 3 different participants
participants <- sample(total_participants, votes_per_judge, replace = FALSE)
for (p in participants) {
votes[p] <- votes[p] + 1
}
}
return(votes)
}
# Function to perform the simulation and calculate probabilities
calculate_probabilities <- function(total_judges, votes_per_judge, total_participants, simulations, num_vote_obtained) {
for (s in 1:simulations) {
votes <- simulate_voting(total_judges, votes_per_judge, total_participants)
the_fourth <- sort(votes, decreasing = TRUE)[4]
fourth_store <- c(fourth_store, the_fourth)
}
probabilities <- sum(num_vote_obtained > fourth_store) / simulations
return(probabilities)
}
# Calculate the probabilities
probabilities <- calculate_probabilities(total_judges = 50, votes_per_judge = 3, total_participants = 20, simulations = 10000, num_vote_obtained = 50)
# Function to simulate one round of voting
simulate_voting <- function(total_judges, votes_per_judge, total_participants) {
votes <- rep(0, total_participants)
for (j in 1:total_judges) {
# Each judge gives votes to 3 different participants
participants <- sample(total_participants, votes_per_judge, replace = FALSE)
for (p in participants) {
votes[p] <- votes[p] + 1
}
}
return(votes)
}
fourth_store <- c()
for (s in 1:simulations) {
votes <- simulate_voting(total_judges, votes_per_judge, total_participants)
the_fourth <- sort(votes, decreasing = TRUE)[4]
fourth_store <- c(fourth_store, the_fourth)
}
simulations
sum(fourth_store >= 50) / simulations
sum(50 >= fourth_store) / simulations
sum(10 >= fourth_store) / simulations
sum(4 >= fourth_store) / simulations
sum(5 >= fourth_store) / simulations
sum(6 >= fourth_store) / simulations
sum(8 >= fourth_store) / simulations
sum(9 >= fourth_store) / simulations
sum(10 >= fourth_store) / simulations
?sample
sample(20, 3)
sample(20, 3, replace = T)
sample(20, 3, replace = F)
set.seed(123)  # Set a seed for reproducibility
total_judges <- 50
votes_per_judge <- 3
total_participants <- 20
simulations <- 10000  # Number of simulations to perform
# Function to simulate one round of voting
simulate_voting <- function(total_judges, votes_per_judge, total_participants) {
votes <- rep(0, total_participants)
for (j in 1:total_judges) {
# Each judge gives votes to 3 different participants
participants <- sample(total_participants, votes_per_judge, replace = FALSE)
for (p in participants) {
votes[p] <- votes[p] + 1
}
}
return(votes)
}
fourth_store <- c()
for (s in 1:100000) {
votes <- simulate_voting(total_judges = 50, votes_per_judge = 3, total_participants = 20)
the_fourth <- sort(votes, decreasing = TRUE)[4]
fourth_store <- c(fourth_store, the_fourth)
}
sum(10 >= fourth_store) / 100000
sum(9 >= fourth_store) / 100000
sum(50 >= fourth_store) / 100000
sum(40 >= fourth_store) / 100000
sum(20 >= fourth_store) / 100000
sum(7 >= fourth_store) / 100000
sum(9 >= fourth_store) / 100000
sum(8 >= fourth_store) / 100000
sum(10 >= fourth_store) / 100000
sum(11 >= fourth_store) / 100000
library(PRECISION.seq.augmented)
